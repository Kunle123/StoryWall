// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  clerkId   String   @unique @map("clerk_id") @db.VarChar(255)
  username  String   @unique @db.VarChar(50)
  email     String   @unique @db.VarChar(255)
  avatarUrl String?  @map("avatar_url")
  credits   Int      @default(100) @map("credits")
  twitterAccessToken String? @map("twitter_access_token") @db.Text
  twitterRefreshToken String? @map("twitter_refresh_token") @db.Text
  // OAuth 1.0a credentials for media uploads (v1.1 endpoint requires OAuth 1.0a)
  twitterOAuth1Token String? @map("twitter_oauth1_token") @db.Text
  twitterOAuth1TokenSecret String? @map("twitter_oauth1_token_secret") @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  timelines      Timeline[]     @relation("TimelineCreator")
  events     Event[]
  collaborations Collaborator[]
  comments   Comment[]
  likes      Like[]
  following  Follow[]          @relation("UserFollowing")
  followers  Follow[]          @relation("UserFollowers")

  @@map("users")
}

model Timeline {
  id                String   @id @default(uuid())
  title             String   @db.VarChar(255)
  description       String?
  slug              String   @unique @db.VarChar(255)
  creatorId         String   @map("creator_id")
  visualizationType String   @default("horizontal") @map("visualization_type") @db.VarChar(50)
  isPublic          Boolean  @default(true) @map("is_public")
  isCollaborative   Boolean  @default(false) @map("is_collaborative")
  isNumbered        Boolean  @default(false) @map("is_numbered")
  numberLabel       String?  @default("Day") @map("number_label") @db.VarChar(50)
  hashtags          String[] @default([]) @map("hashtags")
  viewCount         Int      @default(0) @map("view_count")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Relations
  creator       User           @relation("TimelineCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  events        Event[]
  categories    Category[]
  collaborators Collaborator[]
  comments      Comment[]
  likes         Like[]

  @@index([slug])
  @@index([creatorId])
  @@index([isPublic])
  @@map("timelines")
}

model Event {
  id           String    @id @default(uuid())
  timelineId   String    @map("timeline_id")
  title        String    @db.VarChar(255)
  description  String?
  date         DateTime  @db.Date
  endDate      DateTime? @map("end_date") @db.Date
  number       Int?      @map("number") // For numbered events (1, 2, 3...)
  numberLabel  String?  @map("number_label") @db.VarChar(50) // Label for numbered events (e.g., "Day", "Event")
  imageUrl     String?   @map("image_url")
  imagePrompt  String?   @map("image_prompt") @db.Text // The AI-generated prompt used to create the image
  locationLat  Decimal?  @map("location_lat") @db.Decimal(10, 8)
  locationLng  Decimal?  @map("location_lng") @db.Decimal(11, 8)
  locationName String?   @map("location_name") @db.VarChar(255)
  category     String?   @db.VarChar(100)
  links        String[]  @db.Text
  createdBy    String?   @map("created_by")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  // Relations
  timeline Timeline @relation(fields: [timelineId], references: [id], onDelete: Cascade)
  creator  User?    @relation(fields: [createdBy], references: [id])
  comments Comment[]
  likes    Like[]

  @@index([timelineId])
  @@index([date])
  @@map("events")
}

model Category {
  id         String   @id @default(uuid())
  timelineId String   @map("timeline_id")
  name       String   @db.VarChar(100)
  color      String   @db.VarChar(7) // Hex color
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  timeline Timeline @relation(fields: [timelineId], references: [id], onDelete: Cascade)

  @@index([timelineId])
  @@map("categories")
}

model Collaborator {
  id         String   @id @default(uuid())
  timelineId String   @map("timeline_id")
  userId     String   @map("user_id")
  role       String   @default("editor") @db.VarChar(20) // 'editor' or 'viewer'
  addedAt    DateTime @default(now()) @map("added_at")

  // Relations
  timeline Timeline @relation(fields: [timelineId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([timelineId, userId])
  @@index([timelineId])
  @@index([userId])
  @@map("collaborators")
}

model Comment {
  id         String   @id @default(uuid())
  timelineId String   @map("timeline_id")
  eventId    String?  @map("event_id")
  parentId   String?  @map("parent_id")
  userId     String   @map("user_id")
  content    String   @db.Text
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // Relations
  timeline Timeline @relation(fields: [timelineId], references: [id], onDelete: Cascade)
  event    Event?   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  parent   Comment? @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[] @relation("CommentReplies")
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes    Like[]

  @@index([timelineId])
  @@index([eventId])
  @@index([parentId])
  @@index([userId])
  @@map("comments")
}

model Like {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  timelineId String?  @map("timeline_id")
  eventId    String?  @map("event_id")
  commentId  String?  @map("comment_id")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeline Timeline? @relation(fields: [timelineId], references: [id], onDelete: Cascade)
  event    Event?    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  comment  Comment?  @relation(fields: [commentId], references: [id], onDelete: Cascade)

  // Unique constraints: a user can only like a timeline once, an event once, or a comment once
  // Note: Application-level validation should ensure only one of timelineId, eventId, or commentId is set
  @@unique([userId, timelineId])
  @@unique([userId, eventId])
  @@unique([userId, commentId])
  @@index([userId])
  @@index([timelineId])
  @@index([eventId])
  @@index([commentId])
  @@map("likes")
}

model Follow {
  id          String   @id @default(uuid())
  followerId String   @map("follower_id")
  followingId String   @map("following_id")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  follower  User   @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following User   @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}
